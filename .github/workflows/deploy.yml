name: Deploy

on:
  push:
    branches:
      - docker-dev
  workflow_dispatch:

env:
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  CONFIG_ENV: ${{ secrets.CONFIG_ENV }}
  PORT: ${{ secrets.PORT }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      # 3. Create archive (Source Code)
      - name: Create source archive
        run: tar -czf source.tar.gz . --exclude=node_modules --exclude=.git --exclude=.github

      # 4. Upload Artifact (Optional, for debugging)
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: source-code
          path: source.tar.gz

      # 5. Copy files to server via SCP
      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          port: ${{ env.SSH_PORT }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "source.tar.gz"
          target: "/home/apps/${{ github.event.repository.name }}"
          overwrite: true

      # 6. Deploy via SSH
      - name: Deploy on server
        uses: appleboy/ssh-action@v1.0.3
        env:
          APP_NAME: ${{ env.APP_NAME }}
          DEPLOY_DIR: ${{ env.DEPLOY_DIR }}
          PORT: ${{ env.PORT }}
          CONFIG_ENV: ${{ env.CONFIG_ENV }}
        with:
          host: ${{ env.SSH_HOST }}
          port: ${{ env.SSH_PORT }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          envs: APP_NAME,DEPLOY_DIR,PORT,CONFIG_ENV
          script_stop: true
          script: |
            set -e
            DEPLOY_DIR=${DEPLOY_DIR:-/home/apps/${APP_NAME}}
            echo "Deploying to $DEPLOY_DIR"
            
            # Ensure directory exists
            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            # Create/Update .env file from GitHub Variable
            echo "$CONFIG_ENV" > .env

            # Extract source code
            if [ -f "source.tar.gz" ]; then
              tar -xzf source.tar.gz
              rm source.tar.gz
            else
              echo "Error: source.tar.gz not found!"
              exit 1
            fi

            # Health Check Function
            health_check() {
              local url="http://localhost:${PORT}/health"
              local max_retries=12 # 12 * 5s = 60s timeout
              local count=0
              
              echo "Waiting for service to be healthy at $url..."
              until curl -s -f "$url" > /dev/null; do
                count=$((count + 1))
                if [ $count -ge $max_retries ]; then
                  echo "Health check failed after $max_retries attempts."
                  return 1
                fi
                echo "Attempt $count/$max_retries: Service not ready yet..."
                sleep 5
              done
              echo "Service is healthy!"
              return 0
            }

            # Backup logic (simple: backup docker-compose if exists)
            timestamp=$(date +%Y%m%d%H%M%S)
            mkdir -p backups
            if [ -f "docker-compose.yml" ]; then
              cp docker-compose.yml "backups/docker-compose.yml.$timestamp"
            fi

            # Deploy using Docker Compose (Builds image on server)
            DCMD="docker compose"
            if ! command -v docker &> /dev/null; then
                echo "Docker not found"
                exit 1
            fi
            
            echo "Starting deployment..."
            $DCMD down
            $DCMD up -d --build
            
            # Verify deployment
            set +e
            ok=0
            health_check
            if [ $? -eq 0 ]; then
               echo "Deployment successful!"
            else
               echo "Deployment failed! Rolling back..."
               # Rollback logic could be complex here since we overwrote source.
               # But for now, we just try to restart the previous container if possible or just fail.
               # Since we replaced source, true rollback requires keeping previous source dir.
               # For simplicity in this iteration: just report fail.
               $DCMD logs --tail 50
               exit 1
            fi
